##事务规范
* 使用声明式事务：com.greatonce.core.databse.TransactionTemplate
* 查询一般禁止放在事务内
* 事务内访问表顺序需一致，例如A方法事务内访问顺序 T1>T2，B方法内访问顺序为T2>T1，会导致死锁
* 事务内包含大量操作或长时间操作时需要设置超时时间

### 事务传播范围

* _REQUIRED_ 
如果当前方法有事务则加入事务，没有则创建一个事务。

* _NOT_SUPPORTED_
不支持事务，如果当前有事务则挂起事务运行。

* _REQUIREDS_NEW_
新建一个事务并在这个事务中运行，如果当前存在事务就把当前事务挂起。新建的事务的提交与回滚一挂起事务没有联系，不会影响挂起事务的操作。

* _MANDATORY_
强制当前方法使用事务运行，如果当前没有事务则抛出异常。

* _NEVER_
当前方法不能存在事务，即非事务状态运行，如果存在事务则抛出异常。

* _SUPPORTS_
支持当前事务，如果当前没事务也支持非事务状态运行。

* _NESTED_
如果当前存在事务，则在嵌套事务内执行。嵌套事务的提交与回滚与父事务没有任务关系，反之，当父事务提交嵌套事务也一起提交，父事务回滚会也回滚嵌套事务的。
如果当前没有事务，则新建一个事务运行，这时候则与PROPAGATION_REQUIRED场景一致。


### 事务级别

* _Read uncommitted_
允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。

* _Read Committed_
允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。

* _Repeatable Read_
禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。

* _Serializable_
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到
